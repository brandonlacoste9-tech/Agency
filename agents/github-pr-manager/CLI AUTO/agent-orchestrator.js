"use strict";
/**
 * Agent Orchestrator
 *
 * Manages multiple specialized agents, handles task distribution,
 * load balancing, health monitoring, and coordination
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentOrchestrator = void 0;
var events_1 = require("events");
var AgentOrchestrator = /** @class */ (function (_super) {
    __extends(AgentOrchestrator, _super);
    function AgentOrchestrator(config, logger) {
        var _this = this;
        n;
        _this = _super.call(this) || this;
        _this.agents = new Map();
        _this.agentHealth = new Map();
        _this.taskQueue = [];
        _this.activeTasks = new Map();
        _this.agentLoad = new Map();
        _this.healthCheckInterval = null;
        _this.queueProcessorInterval = null;
        n;
        _this.config = config;
        n;
        _this.logger = logger;
        n;
        _this.startHealthMonitoring();
        n;
        _this.startQueueProcessor();
        n;
        return _this;
    }
    AgentOrchestrator.prototype.registerAgent = function (capability) {
        return __awaiter(this, void 0, void 0, function () { var agentId; return __generator(this, function (_a) {
            n;
            agentId = "".concat(capability.type, "-").concat(Date.now());
            n;
            n;
            this.agents.set(agentId, capability);
            n;
            this.agentLoad.set(agentId, 0);
            n;
            n;
            return [2 /*return*/];
        }); });
    };
    return AgentOrchestrator;
}(events_1.EventEmitter)); // Initialize health status\n    this.agentHealth.set(agentId, {\n      agentId,\n      type: capability.type,\n      status: 'healthy',\n      lastHeartbeat: new Date(),\n      currentLoad: 0,\n      activeTaskCount: 0,\n      queueLength: 0,\n      averageResponseTime: 0,\n      errorRate: 0,\n      uptime: 0\n    });\n\n    this.logger.info('Agent registered', {\n      agentId,\n      type: capability.type,\n      endpoint: capability.endpoint\n    });\n\n    this.emit('agent_registered', { agentId, capability });\n  }\n\n  /**\n   * Unregister an agent\n   */\n  async unregisterAgent(agentId: string): Promise<void> {\n    // Cancel any active tasks for this agent\n    const activeTasks = Array.from(this.activeTasks.entries())\n      .filter(([_, context]) => context.agentEndpoint === this.agents.get(agentId)?.endpoint);\n\n    for (const [taskId] of activeTasks) {\n      await this.cancelTask(taskId);\n    }\n\n    this.agents.delete(agentId);\n    this.agentHealth.delete(agentId);\n    this.agentLoad.delete(agentId);\n\n    this.logger.info('Agent unregistered', { agentId });\n    this.emit('agent_unregistered', { agentId });\n  }\n\n  /**\n   * Execute a single task by finding the best available agent\n   */\n  async executeTask(task: AgentTask): Promise<TaskResult> {\n    try {\n      // Find the best agent for this task\n      const agent = await this.selectAgent(task);\n      \n      if (!agent) {\n        throw new Error(`No available agent for task type: ${task.type}`);\n      }\n\n      const agentCapability = this.agents.get(agent)!;\n      \n      // Create execution context\n      const context: TaskExecutionContext = {\n        taskId: task.id,\n        prContext: {} as any, // Will be set by caller\n        agentEndpoint: agentCapability.endpoint,\n        timeout: task.timeout,\n        retries: task.retries,\n        startTime: new Date(),\n        metadata: {\n          traceId: `trace-${task.id}-${Date.now()}`\n        }\n      };\n\n      this.activeTasks.set(task.id, context);\n      this.updateAgentLoad(agent, 1);\n\n      task.status = 'running';\n      task.assignedAgent = agent;\n      task.startedAt = new Date();\n\n      this.logger.info('Executing task', {\n        taskId: task.id,\n        type: task.type,\n        agentId: agent,\n        endpoint: agentCapability.endpoint\n      });\n\n      // Execute the task\n      const result = await this.executeTaskOnAgent(task, agentCapability, context);\n\n      // Update metrics\n      this.updateAgentLoad(agent, -1);\n      this.activeTasks.delete(task.id);\n\n      result.startedAt = task.startedAt;\n      result.completedAt = new Date();\n\n      this.emit('task_completed', result);\n      return result;\n\n    } catch (error) {\n      this.logger.error('Task execution failed', {\n        taskId: task.id,\n        error: error instanceof Error ? error.message : String(error)\n      });\n\n      const result: TaskResult = {\n        task,\n        status: 'failed',\n        error: error instanceof Error ? error : new Error(String(error)),\n        startedAt: task.startedAt,\n        completedAt: new Date()\n      };\n\n      this.emit('task_failed', result);\n      return result;\n    }\n  }\n\n  /**\n   * Execute multiple tasks concurrently\n   */\n  async executeTasks(tasks: AgentTask[]): Promise<TaskResult[]> {\n    this.logger.info('Executing batch of tasks', {\n      taskCount: tasks.length,\n      taskTypes: [...new Set(tasks.map(t => t.type))]\n    });\n\n    // Sort tasks by priority\n    const sortedTasks = [...tasks].sort((a, b) => {\n      const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };\n      return priorityOrder[b.priority] - priorityOrder[a.priority];\n    });\n\n    // Execute tasks with concurrency limit\n    const results: TaskResult[] = [];\n    const concurrencyLimit = this.config.maxConcurrentTasks || 5;\n    \n    for (let i = 0; i < sortedTasks.length; i += concurrencyLimit) {\n      const batch = sortedTasks.slice(i, i + concurrencyLimit);\n      const batchResults = await Promise.allSettled(\n        batch.map(task => this.executeTask(task))\n      );\n\n      // Process batch results\n      batchResults.forEach((result, index) => {\n        if (result.status === 'fulfilled') {\n          results.push(result.value);\n        } else {\n          // Create failed task result\n          results.push({\n            task: batch[index],\n            status: 'failed',\n            error: result.reason,\n            completedAt: new Date()\n          });\n        }\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Queue a task for later execution\n   */\n  async queueTask(task: AgentTask, priority?: number): Promise<void> {\n    const queueItem: TaskQueueItem = {\n      task,\n      priority: priority || this.getPriorityValue(task.priority),\n      queuedAt: new Date(),\n      attempts: 0\n    };\n\n    this.taskQueue.push(queueItem);\n    this.taskQueue.sort((a, b) => b.priority - a.priority);\n\n    this.logger.info('Task queued', {\n      taskId: task.id,\n      type: task.type,\n      priority: task.priority,\n      queueLength: this.taskQueue.length\n    });\n\n    this.emit('task_queued', queueItem);\n  }\n\n  /**\n   * Pause tasks by IDs\n   */\n  async pauseTasks(taskIds: string[]): Promise<void> {\n    for (const taskId of taskIds) {\n      const context = this.activeTasks.get(taskId);\n      if (context) {\n        // Send pause signal to agent\n        await this.sendAgentCommand(context.agentEndpoint, 'pause', { taskId });\n        this.logger.info('Task paused', { taskId });\n      }\n    }\n  }\n\n  /**\n   * Cancel a task\n   */\n  async cancelTask(taskId: string): Promise<void> {\n    const context = this.activeTasks.get(taskId);\n    if (context) {\n      await this.sendAgentCommand(context.agentEndpoint, 'cancel', { taskId });\n      this.activeTasks.delete(taskId);\n      this.logger.info('Task cancelled', { taskId });\n    }\n\n    // Remove from queue if present\n    this.taskQueue = this.taskQueue.filter(item => item.task.id !== taskId);\n  }\n\n  /**\n   * Get system status and metrics\n   */\n  getSystemStatus(): any {\n    const agents = Array.from(this.agents.values());\n    const healthStatuses = Array.from(this.agentHealth.values());\n    \n    return {\n      agents: {\n        total: agents.length,\n        online: agents.filter(a => a.status === 'online').length,\n        busy: agents.filter(a => a.status === 'busy').length,\n        offline: agents.filter(a => a.status === 'offline').length\n      },\n      tasks: {\n        active: this.activeTasks.size,\n        queued: this.taskQueue.length\n      },\n      health: {\n        healthy: healthStatuses.filter(h => h.status === 'healthy').length,\n        degraded: healthStatuses.filter(h => h.status === 'degraded').length,\n        unhealthy: healthStatuses.filter(h => h.status === 'unhealthy').length\n      },\n      load: {\n        average: this.calculateAverageLoad(),\n        peak: this.calculatePeakLoad()\n      }\n    };\n  }\n\n  /**\n   * Select the best agent for a task based on availability, capability, and load\n   */\n  private async selectAgent(task: AgentTask): Promise<string | null> {\n    const candidateAgents = Array.from(this.agents.entries())\n      .filter(([agentId, capability]) => {\n        // Check if agent supports this task type\n        if (!capability.supportedTasks.includes(task.type)) {\n          return false;\n        }\n        \n        // Check if agent is online and healthy\n        const health = this.agentHealth.get(agentId);\n        if (!health || health.status !== 'healthy') {\n          return false;\n        }\n        \n        // Check if agent has capacity\n        const currentLoad = this.agentLoad.get(agentId) || 0;\n        if (currentLoad >= capability.maxConcurrentTasks) {\n          return false;\n        }\n        \n        return true;\n      });\n\n    if (candidateAgents.length === 0) {\n      return null;\n    }\n\n    // Select agent with lowest load and best performance\n    const selectedAgent = candidateAgents.reduce((best, [agentId, capability]) => {\n      const load = this.agentLoad.get(agentId) || 0;\n      const health = this.agentHealth.get(agentId)!;\n      \n      // Calculate selection score (lower is better)\n      const loadScore = load / capability.maxConcurrentTasks;\n      const performanceScore = 1 - capability.successRate;\n      const responseTimeScore = health.averageResponseTime / 1000; // normalize to seconds\n      \n      const totalScore = loadScore + performanceScore + responseTimeScore;\n      \n      if (!best.bestScore || totalScore < best.bestScore) {\n        return { agentId, bestScore: totalScore };\n      }\n      \n      return best;\n    }, { agentId: '', bestScore: 0 } as { agentId: string; bestScore: number });\n\n    return selectedAgent.agentId;\n  }\n\n  /**\n   * Execute task on specific agent\n   */\n  private async executeTaskOnAgent(\n    task: AgentTask, \n    capability: AgentCapability, \n    context: TaskExecutionContext\n  ): Promise<TaskResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Send task to agent\n      const response = await this.sendTaskToAgent(capability.endpoint, task, context);\n      \n      const result: TaskResult = {\n        task,\n        status: response.status,\n        output: response.result,\n        metadata: {\n          agentId: response.metadata.agentId,\n          agentVersion: response.metadata.agentVersion,\n          executionTime: response.metadata.executionTime\n        }\n      };\n\n      // Update agent metrics\n      this.updateAgentMetrics(capability, response, Date.now() - startTime);\n      \n      return result;\n      \n    } catch (error) {\n      // Handle timeout, network errors, etc.\n      const result: TaskResult = {\n        task,\n        status: 'failed',\n        error: error instanceof Error ? error : new Error(String(error))\n      };\n      \n      // Update error metrics\n      this.updateAgentErrorMetrics(capability, error);\n      \n      return result;\n    }\n  }\n\n  /**\n   * Send task to agent via HTTP API\n   */\n  private async sendTaskToAgent(\n    endpoint: string, \n    task: AgentTask, \n    context: TaskExecutionContext\n  ): Promise<AgentResponse> {\n    const response = await fetch(`${endpoint}/execute`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Trace-ID': context.metadata.traceId\n      },\n      body: JSON.stringify({\n        task,\n        context: {\n          timeout: context.timeout,\n          retries: context.retries\n        }\n      }),\n      signal: AbortSignal.timeout(task.timeout)\n    });\n\n    if (!response.ok) {\n      throw new Error(`Agent request failed: ${response.status} ${response.statusText}`);\n    }\n\n    return await response.json();\n  }\n\n  /**\n   * Send command to agent (pause, cancel, etc.)\n   */\n  private async sendAgentCommand(endpoint: string, command: string, payload: any): Promise<void> {\n    await fetch(`${endpoint}/command`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ command, payload })\n    });\n  }\n\n  /**\n   * Update agent load counter\n   */\n  private updateAgentLoad(agentId: string, delta: number): void {\n    const currentLoad = this.agentLoad.get(agentId) || 0;\n    this.agentLoad.set(agentId, Math.max(0, currentLoad + delta));\n  }\n\n  /**\n   * Update agent performance metrics\n   */\n  private updateAgentMetrics(capability: AgentCapability, response: AgentResponse, totalTime: number): void {\n    // Update success rate, average execution time, etc.\n    // This would integrate with a metrics storage system\n  }\n\n  /**\n   * Update agent error metrics\n   */\n  private updateAgentErrorMetrics(capability: AgentCapability, error: any): void {\n    // Track error rates, failure patterns, etc.\n  }\n\n  /**\n   * Start health monitoring for all agents\n   */\n  private startHealthMonitoring(): void {\n    this.healthCheckInterval = setInterval(async () => {\n      await this.performHealthChecks();\n    }, 30000); // Check every 30 seconds\n  }\n\n  /**\n   * Start queue processor\n   */\n  private startQueueProcessor(): void {\n    this.queueProcessorInterval = setInterval(async () => {\n      await this.processQueue();\n    }, 5000); // Process queue every 5 seconds\n  }\n\n  /**\n   * Perform health checks on all agents\n   */\n  private async performHealthChecks(): Promise<void> {\n    const healthCheckPromises = Array.from(this.agents.entries()).map(async ([agentId, capability]) => {\n      try {\n        const response = await fetch(`${capability.endpoint}/health`, {\n          method: 'GET',\n          signal: AbortSignal.timeout(5000) // 5 second timeout\n        });\n\n        const healthData = await response.json();\n        \n        this.agentHealth.set(agentId, {\n          agentId,\n          type: capability.type,\n          status: response.ok ? 'healthy' : 'degraded',\n          lastHeartbeat: new Date(),\n          currentLoad: this.agentLoad.get(agentId) || 0,\n          activeTaskCount: healthData.activeTaskCount || 0,\n          queueLength: healthData.queueLength || 0,\n          averageResponseTime: healthData.averageResponseTime || 0,\n          errorRate: healthData.errorRate || 0,\n          uptime: healthData.uptime || 0\n        });\n        \n      } catch (error) {\n        // Mark agent as unhealthy\n        const currentHealth = this.agentHealth.get(agentId);\n        if (currentHealth) {\n          currentHealth.status = 'unhealthy';\n          this.agentHealth.set(agentId, currentHealth);\n        }\n        \n        this.logger.warn('Agent health check failed', {\n          agentId,\n          endpoint: capability.endpoint,\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n    });\n\n    await Promise.allSettled(healthCheckPromises);\n  }\n\n  /**\n   * Process queued tasks\n   */\n  private async processQueue(): Promise<void> {\n    if (this.taskQueue.length === 0) {\n      return;\n    }\n\n    const availableCapacity = this.calculateAvailableCapacity();\n    if (availableCapacity <= 0) {\n      return;\n    }\n\n    const tasksToProcess = this.taskQueue.splice(0, Math.min(availableCapacity, this.taskQueue.length));\n    \n    for (const queueItem of tasksToProcess) {\n      try {\n        queueItem.attempts++;\n        const result = await this.executeTask(queueItem.task);\n        \n        if (result.status === 'failed' && queueItem.attempts < queueItem.task.retries) {\n          // Retry failed task\n          queueItem.nextRetryAt = new Date(Date.now() + (queueItem.attempts * 5000)); // Exponential backoff\n          this.taskQueue.push(queueItem);\n          this.taskQueue.sort((a, b) => b.priority - a.priority);\n        }\n        \n      } catch (error) {\n        this.logger.error('Queue processing failed', {\n          taskId: queueItem.task.id,\n          attempts: queueItem.attempts,\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n    }\n  }\n\n  /**\n   * Calculate available capacity across all agents\n   */\n  private calculateAvailableCapacity(): number {\n    return Array.from(this.agents.entries()).reduce((total, [agentId, capability]) => {\n      const health = this.agentHealth.get(agentId);\n      if (!health || health.status !== 'healthy') {\n        return total;\n      }\n      \n      const currentLoad = this.agentLoad.get(agentId) || 0;\n      return total + Math.max(0, capability.maxConcurrentTasks - currentLoad);\n    }, 0);\n  }\n\n  /**\n   * Calculate average system load\n   */\n  private calculateAverageLoad(): number {\n    const agents = Array.from(this.agents.entries());\n    if (agents.length === 0) return 0;\n    \n    const totalLoad = agents.reduce((sum, [agentId, capability]) => {\n      const load = this.agentLoad.get(agentId) || 0;\n      return sum + (load / capability.maxConcurrentTasks);\n    }, 0);\n    \n    return totalLoad / agents.length;\n  }\n\n  /**\n   * Calculate peak system load\n   */\n  private calculatePeakLoad(): number {\n    return Array.from(this.agents.entries()).reduce((peak, [agentId, capability]) => {\n      const load = this.agentLoad.get(agentId) || 0;\n      const loadPercentage = load / capability.maxConcurrentTasks;\n      return Math.max(peak, loadPercentage);\n    }, 0);\n  }\n\n  /**\n   * Convert priority string to numeric value\n   */\n  private getPriorityValue(priority: string): number {\n    const priorityMap = { critical: 4, high: 3, medium: 2, low: 1 };\n    return priorityMap[priority as keyof typeof priorityMap] || 1;\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n    }\n    \n    if (this.queueProcessorInterval) {\n      clearInterval(this.queueProcessorInterval);\n    }\n    \n    this.removeAllListeners();\n  }\n}
exports.AgentOrchestrator = AgentOrchestrator;
