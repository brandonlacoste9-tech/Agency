var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
n;
nimport;
{
    Octokit;
}
from;
'@octokit/rest';
nimport;
{
    Logger;
}
from;
'../../lib/logger';
nimport;
{
    PRAnalysis;
}
from;
'./types';
n;
nexport;
var PRAnalyzer = /** @class */ (function () {
    function PRAnalyzer(octokit, logger) {
        n;
        this.octokit = octokit;
        n;
        this.logger = logger;
        n;
    }
    PRAnalyzer.prototype.analyzePR = function (pullRequest, repository) {
        return __awaiter(this, void 0, void 0, function () { var prNumber, repoOwner, repoName, fullRepoName; return __generator(this, function (_a) {
            n;
            prNumber = pullRequest.number;
            n;
            repoOwner = repository.owner.login;
            n;
            repoName = repository.name;
            n;
            fullRepoName = repository.full_name;
            n;
            n;
            this.logger.info('Starting PR analysis', { n: n, pr: "".concat(fullRepoName, "#").concat(prNumber), n: n, title: pullRequest.title, n: n });
            n;
            n;
            try {
                n;
            }
            finally { }
            return [2 /*return*/];
        }); });
    };
    return PRAnalyzer;
}()); // Get file changes\n      const files = await this.getModifiedFiles(repoOwner, repoName, prNumber);\n      const { addedLines, deletedLines } = this.calculateLineChanges(files);\n      \n      // Analyze languages and complexity\n      const languages = this.analyzeLanguages(files);\n      const primaryLanguage = this.determinePrimaryLanguage(languages);\n      const complexity = this.assessComplexity(files, addedLines, deletedLines);\n      \n      // Determine required checks\n      const securityAnalysis = this.analyzeSecurityRequirements(files, pullRequest);\n      const testingAnalysis = this.analyzeTestingRequirements(files, primaryLanguage);\n      const documentationAnalysis = this.analyzeDocumentationRequirements(files, pullRequest);\n      const performanceAnalysis = this.analyzePerformanceRequirements(files, primaryLanguage);\n      const deploymentAnalysis = this.analyzeDeploymentRequirements(files, pullRequest);\n      \n      // Calculate risk level\n      const riskLevel = this.calculateRiskLevel({\n        complexity,\n        securityConcerns: securityAnalysis.securityConcerns.length,\n        linesChanged: addedLines + deletedLines,\n        filesChanged: files.length,\n        hasApiChanges: deploymentAnalysis.apiChanges,\n        hasDatabaseChanges: deploymentAnalysis.databaseMigrations\n      });\n      \n      // Estimate review time\n      const estimatedReviewTime = this.estimateReviewTime({\n        complexity,\n        filesCount: files.length,\n        linesChanged: addedLines + deletedLines,\n        requiresSecurityReview: securityAnalysis.requiresSecurityReview,\n        requiresPerformanceReview: performanceAnalysis.requiresPerformanceReview\n      });\n\n      const analysis: PRAnalysis = {\n        id: `analysis-${prNumber}-${Date.now()}`,\n        prNumber,\n        repository: fullRepoName,\n        modifiedFiles: files.map(f => f.filename),\n        addedLines,\n        deletedLines,\n        primaryLanguage,\n        languages: Object.keys(languages),\n        complexity,\n        requiresSecurityReview: securityAnalysis.requiresSecurityReview,\n        requiresCodeReview: this.requiresCodeReview(complexity, addedLines + deletedLines),\n        requiresTesting: testingAnalysis.requiresTesting,\n        requiresDocumentation: documentationAnalysis.requiresDocumentation,\n        requiresPerformanceReview: performanceAnalysis.requiresPerformanceReview,\n        requiresDeploymentCheck: deploymentAnalysis.requiresDeploymentCheck,\n        securityConcerns: securityAnalysis.securityConcerns,\n        testFiles: testingAnalysis.testFiles,\n        documentationFiles: documentationAnalysis.documentationFiles,\n        apiChanges: deploymentAnalysis.apiChanges,\n        databaseMigrations: deploymentAnalysis.databaseMigrations,\n        performancePaths: performanceAnalysis.performancePaths,\n        targetEnvironment: deploymentAnalysis.targetEnvironment,\n        testStrategy: testingAnalysis.testStrategy,\n        riskLevel,\n        estimatedReviewTime\n      };\n\n      this.logger.info('PR analysis completed', {\n        pr: `${fullRepoName}#${prNumber}`,\n        complexity,\n        riskLevel,\n        estimatedTime: estimatedReviewTime,\n        checksRequired: {\n          security: analysis.requiresSecurityReview,\n          testing: analysis.requiresTesting,\n          documentation: analysis.requiresDocumentation,\n          performance: analysis.requiresPerformanceReview,\n          deployment: analysis.requiresDeploymentCheck\n        }\n      });\n\n      return analysis;\n\n    } catch (error) {\n      this.logger.error('PR analysis failed', {\n        pr: `${fullRepoName}#${prNumber}`,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get modified files from the PR\n   */\n  private async getModifiedFiles(owner: string, repo: string, prNumber: number): Promise<any[]> {\n    const { data: files } = await this.octokit.pulls.listFiles({\n      owner,\n      repo,\n      pull_number: prNumber\n    });\n    \n    return files;\n  }\n\n  /**\n   * Calculate total lines added and deleted\n   */\n  private calculateLineChanges(files: any[]): { addedLines: number; deletedLines: number } {\n    return files.reduce(\n      (acc, file) => ({\n        addedLines: acc.addedLines + file.additions,\n        deletedLines: acc.deletedLines + file.deletions\n      }),\n      { addedLines: 0, deletedLines: 0 }\n    );\n  }\n\n  /**\n   * Analyze programming languages in the PR\n   */\n  private analyzeLanguages(files: any[]): Record<string, number> {\n    const languages: Record<string, number> = {};\n    \n    files.forEach(file => {\n      const extension = file.filename.split('.').pop()?.toLowerCase();\n      if (extension) {\n        const language = this.getLanguageFromExtension(extension);\n        if (language) {\n          languages[language] = (languages[language] || 0) + (file.additions + file.deletions);\n        }\n      }\n    });\n    \n    return languages;\n  }\n\n  /**\n   * Determine primary programming language\n   */\n  private determinePrimaryLanguage(languages: Record<string, number>): string {\n    if (Object.keys(languages).length === 0) {\n      return 'unknown';\n    }\n    \n    return Object.entries(languages)\n      .sort(([, a], [, b]) => b - a)[0][0];\n  }\n\n  /**\n   * Map file extension to programming language\n   */\n  private getLanguageFromExtension(extension: string): string | null {\n    const extensionMap: Record<string, string> = {\n      'ts': 'typescript',\n      'tsx': 'typescript',\n      'js': 'javascript',\n      'jsx': 'javascript',\n      'py': 'python',\n      'java': 'java',\n      'kt': 'kotlin',\n      'swift': 'swift',\n      'go': 'go',\n      'rs': 'rust',\n      'cpp': 'cpp',\n      'c': 'c',\n      'cs': 'csharp',\n      'php': 'php',\n      'rb': 'ruby',\n      'scala': 'scala',\n      'clj': 'clojure',\n      'hs': 'haskell',\n      'elm': 'elm',\n      'dart': 'dart',\n      'lua': 'lua',\n      'r': 'r',\n      'sql': 'sql',\n      'html': 'html',\n      'css': 'css',\n      'scss': 'scss',\n      'less': 'less',\n      'vue': 'vue',\n      'svelte': 'svelte',\n      'yaml': 'yaml',\n      'yml': 'yaml',\n      'json': 'json',\n      'xml': 'xml',\n      'md': 'markdown',\n      'dockerfile': 'docker',\n      'sh': 'shell',\n      'bash': 'shell',\n      'zsh': 'shell',\n      'fish': 'shell'\n    };\n    \n    return extensionMap[extension] || null;\n  }\n\n  /**\n   * Assess complexity of the changes\n   */\n  private assessComplexity(files: any[], addedLines: number, deletedLines: number): 'low' | 'medium' | 'high' {\n    const totalLines = addedLines + deletedLines;\n    const fileCount = files.length;\n    \n    // Complexity factors\n    let complexityScore = 0;\n    \n    // Line count factor\n    if (totalLines > 1000) complexityScore += 3;\n    else if (totalLines > 500) complexityScore += 2;\n    else if (totalLines > 100) complexityScore += 1;\n    \n    // File count factor\n    if (fileCount > 20) complexityScore += 3;\n    else if (fileCount > 10) complexityScore += 2;\n    else if (fileCount > 5) complexityScore += 1;\n    \n    // File type complexity\n    files.forEach(file => {\n      const filename = file.filename.toLowerCase();\n      \n      // Core system files\n      if (filename.includes('package.json') || \n          filename.includes('dockerfile') ||\n          filename.includes('docker-compose') ||\n          filename.includes('.env') ||\n          filename.includes('config')) {\n        complexityScore += 2;\n      }\n      \n      // Database migrations\n      if (filename.includes('migration') || \n          filename.includes('schema') ||\n          filename.includes('.sql')) {\n        complexityScore += 2;\n      }\n      \n      // Security-related files\n      if (filename.includes('auth') ||\n          filename.includes('security') ||\n          filename.includes('permission') ||\n          filename.includes('token')) {\n        complexityScore += 2;\n      }\n      \n      // Infrastructure files\n      if (filename.includes('.yml') || \n          filename.includes('.yaml') ||\n          filename.includes('terraform') ||\n          filename.includes('cloudformation')) {\n        complexityScore += 1;\n      }\n    });\n    \n    // Determine complexity level\n    if (complexityScore >= 8) return 'high';\n    if (complexityScore >= 4) return 'medium';\n    return 'low';\n  }\n\n  /**\n   * Analyze security requirements\n   */\n  private analyzeSecurityRequirements(files: any[], pullRequest: any): {\n    requiresSecurityReview: boolean;\n    securityConcerns: string[];\n  } {\n    const securityConcerns: string[] = [];\n    let requiresSecurityReview = false;\n    \n    files.forEach(file => {\n      const filename = file.filename.toLowerCase();\n      const patch = file.patch || '';\n      \n      // Security-sensitive files\n      if (filename.includes('auth') ||\n          filename.includes('security') ||\n          filename.includes('permission') ||\n          filename.includes('token') ||\n          filename.includes('crypto') ||\n          filename.includes('hash') ||\n          filename.includes('password') ||\n          filename.includes('jwt') ||\n          filename.includes('oauth') ||\n          filename.includes('cors') ||\n          filename.includes('middleware/auth') ||\n          filename.includes('middleware/security')) {\n        requiresSecurityReview = true;\n        securityConcerns.push(`Security-sensitive file modified: ${file.filename}`);\n      }\n      \n      // Database/SQL injection concerns\n      if (patch.includes('SELECT ') ||\n          patch.includes('INSERT ') ||\n          patch.includes('UPDATE ') ||\n          patch.includes('DELETE ') ||\n          patch.includes('DROP ') ||\n          patch.includes('ALTER ') ||\n          patch.includes('CREATE ')) {\n        securityConcerns.push(`SQL operations detected in: ${file.filename}`);\n      }\n      \n      // API endpoint changes\n      if (filename.includes('route') ||\n          filename.includes('api/') ||\n          filename.includes('endpoint') ||\n          filename.includes('controller')) {\n        if (patch.includes('app.post') ||\n            patch.includes('app.put') ||\n            patch.includes('app.delete') ||\n            patch.includes('router.post') ||\n            patch.includes('router.put') ||\n            patch.includes('router.delete') ||\n            patch.includes('@PostMapping') ||\n            patch.includes('@PutMapping') ||\n            patch.includes('@DeleteMapping') ||\n            patch.includes('HTTP') ||\n            patch.includes('request') ||\n            patch.includes('response')) {\n          requiresSecurityReview = true;\n          securityConcerns.push(`API endpoint modifications in: ${file.filename}`);\n        }\n      }\n      \n      // Environment/config changes\n      if (filename.includes('.env') ||\n          filename.includes('config') ||\n          filename.includes('secret') ||\n          filename.includes('key')) {\n        requiresSecurityReview = true;\n        securityConcerns.push(`Configuration file modified: ${file.filename}`);\n      }\n      \n      // Dependency changes\n      if (filename.includes('package.json') ||\n          filename.includes('requirements.txt') ||\n          filename.includes('pom.xml') ||\n          filename.includes('build.gradle') ||\n          filename.includes('Cargo.toml') ||\n          filename.includes('go.mod')) {\n        securityConcerns.push(`Dependency changes in: ${file.filename}`);\n      }\n      \n      // Docker/deployment changes\n      if (filename.includes('dockerfile') ||\n          filename.includes('docker-compose') ||\n          filename.includes('.yml') ||\n          filename.includes('.yaml')) {\n        securityConcerns.push(`Infrastructure changes in: ${file.filename}`);\n      }\n    });\n    \n    // Check PR title and description for security keywords\n    const prText = `${pullRequest.title} ${pullRequest.body || ''}`.toLowerCase();\n    const securityKeywords = ['security', 'vulnerability', 'auth', 'permission', 'token', 'crypto', 'password', 'login', 'session', 'cors', 'xss', 'csrf', 'injection', 'encryption'];\n    \n    securityKeywords.forEach(keyword => {\n      if (prText.includes(keyword)) {\n        requiresSecurityReview = true;\n        securityConcerns.push(`Security-related keyword in PR description: ${keyword}`);\n      }\n    });\n    \n    return { requiresSecurityReview, securityConcerns };\n  }\n\n  /**\n   * Analyze testing requirements\n   */\n  private analyzeTestingRequirements(files: any[], primaryLanguage: string): {\n    requiresTesting: boolean;\n    testFiles: string[];\n    testStrategy: 'unit' | 'integration' | 'e2e' | 'all';\n  } {\n    const testFiles: string[] = [];\n    let hasTestChanges = false;\n    let hasCodeChanges = false;\n    \n    files.forEach(file => {\n      const filename = file.filename.toLowerCase();\n      \n      // Identify test files\n      if (filename.includes('test') ||\n          filename.includes('spec') ||\n          filename.includes('__tests__') ||\n          filename.includes('.test.') ||\n          filename.includes('.spec.') ||\n          filename.endsWith('test.ts') ||\n          filename.endsWith('test.js') ||\n          filename.endsWith('spec.ts') ||\n          filename.endsWith('spec.js') ||\n          filename.includes('cypress') ||\n          filename.includes('playwright') ||\n          filename.includes('jest') ||\n          filename.includes('vitest')) {\n        testFiles.push(file.filename);\n        hasTestChanges = true;\n      } else if (!filename.includes('readme') &&\n                 !filename.includes('changelog') &&\n                 !filename.includes('.md') &&\n                 !filename.includes('.txt') &&\n                 !filename.includes('.yml') &&\n                 !filename.includes('.yaml') &&\n                 !filename.includes('.json')) {\n        hasCodeChanges = true;\n      }\n    });\n    \n    const requiresTesting = hasCodeChanges && !hasTestChanges;\n    \n    // Determine test strategy based on file types\n    let testStrategy: 'unit' | 'integration' | 'e2e' | 'all' = 'unit';\n    \n    const hasApiChanges = files.some(f => \n      f.filename.toLowerCase().includes('api/') ||\n      f.filename.toLowerCase().includes('route') ||\n      f.filename.toLowerCase().includes('endpoint') ||\n      f.filename.toLowerCase().includes('controller')\n    );\n    \n    const hasUIChanges = files.some(f =>\n      f.filename.toLowerCase().includes('component') ||\n      f.filename.toLowerCase().includes('page') ||\n      f.filename.toLowerCase().includes('view') ||\n      f.filename.toLowerCase().includes('.tsx') ||\n      f.filename.toLowerCase().includes('.jsx') ||\n      f.filename.toLowerCase().includes('.vue') ||\n      f.filename.toLowerCase().includes('.svelte')\n    );\n    \n    const hasDbChanges = files.some(f =>\n      f.filename.toLowerCase().includes('migration') ||\n      f.filename.toLowerCase().includes('schema') ||\n      f.filename.toLowerCase().includes('model') ||\n      f.filename.toLowerCase().includes('entity')\n    );\n    \n    if (hasUIChanges && hasApiChanges) {\n      testStrategy = 'all';\n    } else if (hasUIChanges) {\n      testStrategy = 'e2e';\n    } else if (hasApiChanges || hasDbChanges) {\n      testStrategy = 'integration';\n    }\n    \n    return { requiresTesting, testFiles, testStrategy };\n  }\n\n  /**\n   * Analyze documentation requirements\n   */\n  private analyzeDocumentationRequirements(files: any[], pullRequest: any): {\n    requiresDocumentation: boolean;\n    documentationFiles: string[];\n  } {\n    const documentationFiles: string[] = [];\n    let hasDocChanges = false;\n    let hasApiChanges = false;\n    let hasPublicAPIChanges = false;\n    \n    files.forEach(file => {\n      const filename = file.filename.toLowerCase();\n      const patch = file.patch || '';\n      \n      // Documentation files\n      if (filename.includes('readme') ||\n          filename.includes('doc') ||\n          filename.includes('.md') ||\n          filename.includes('changelog') ||\n          filename.includes('guide') ||\n          filename.includes('tutorial') ||\n          filename.includes('api.md') ||\n          filename.includes('specification')) {\n        documentationFiles.push(file.filename);\n        hasDocChanges = true;\n      }\n      \n      // API changes that might need documentation\n      if (filename.includes('api/') ||\n          filename.includes('route') ||\n          filename.includes('endpoint') ||\n          filename.includes('controller')) {\n        hasApiChanges = true;\n        \n        // Check for new public endpoints\n        if (patch.includes('export') ||\n            patch.includes('public') ||\n            patch.includes('app.get') ||\n            patch.includes('app.post') ||\n            patch.includes('app.put') ||\n            patch.includes('app.delete') ||\n            patch.includes('router.')) {\n          hasPublicAPIChanges = true;\n        }\n      }\n      \n      // Library/SDK changes\n      if (filename.includes('lib/') ||\n          filename.includes('sdk/') ||\n          filename.includes('utils/') ||\n          filename.includes('helper')) {\n        if (patch.includes('export') ||\n            patch.includes('public') ||\n            patch.includes('function') ||\n            patch.includes('class') ||\n            patch.includes('interface') ||\n            patch.includes('type ')) {\n          hasPublicAPIChanges = true;\n        }\n      }\n    });\n    \n    const requiresDocumentation = (hasApiChanges || hasPublicAPIChanges) && !hasDocChanges;\n    \n    return { requiresDocumentation, documentationFiles };\n  }\n\n  /**\n   * Analyze performance requirements\n   */\n  private analyzePerformanceRequirements(files: any[], primaryLanguage: string): {\n    requiresPerformanceReview: boolean;\n    performancePaths: string[];\n  } {\n    const performancePaths: string[] = [];\n    let requiresPerformanceReview = false;\n    \n    files.forEach(file => {\n      const filename = file.filename.toLowerCase();\n      const patch = file.patch || '';\n      \n      // Performance-critical paths\n      if (filename.includes('api/') ||\n          filename.includes('route') ||\n          filename.includes('endpoint') ||\n          filename.includes('controller') ||\n          filename.includes('service') ||\n          filename.includes('repository') ||\n          filename.includes('query') ||\n          filename.includes('algorithm') ||\n          filename.includes('optimization') ||\n          filename.includes('cache') ||\n          filename.includes('database') ||\n          filename.includes('db/')) {\n        performancePaths.push(file.filename);\n        \n        // Check for performance-impacting changes\n        if (patch.includes('loop') ||\n            patch.includes('for (') ||\n            patch.includes('while (') ||\n            patch.includes('forEach') ||\n            patch.includes('map(') ||\n            patch.includes('filter(') ||\n            patch.includes('reduce(') ||\n            patch.includes('SELECT') ||\n            patch.includes('JOIN') ||\n            patch.includes('GROUP BY') ||\n            patch.includes('ORDER BY') ||\n            patch.includes('async') ||\n            patch.includes('await') ||\n            patch.includes('Promise') ||\n            patch.includes('setTimeout') ||\n            patch.includes('setInterval') ||\n            patch.includes('fetch(') ||\n            patch.includes('axios') ||\n            patch.includes('http.')) {\n          requiresPerformanceReview = true;\n        }\n      }\n      \n      // Large file changes that might impact performance\n      if (file.additions + file.deletions > 500) {\n        requiresPerformanceReview = true;\n        performancePaths.push(file.filename);\n      }\n    });\n    \n    return { requiresPerformanceReview, performancePaths };\n  }\n\n  /**\n   * Analyze deployment requirements\n   */\n  private analyzeDeploymentRequirements(files: any[], pullRequest: any): {\n    requiresDeploymentCheck: boolean;\n    apiChanges: boolean;\n    databaseMigrations: boolean;\n    targetEnvironment: string;\n  } {\n    let requiresDeploymentCheck = false;\n    let apiChanges = false;\n    let databaseMigrations = false;\n    let targetEnvironment = 'development';\n    \n    files.forEach(file => {\n      const filename = file.filename.toLowerCase();\n      \n      // API changes\n      if (filename.includes('api/') ||\n          filename.includes('route') ||\n          filename.includes('endpoint') ||\n          filename.includes('controller')) {\n        apiChanges = true;\n        requiresDeploymentCheck = true;\n      }\n      \n      // Database migrations\n      if (filename.includes('migration') ||\n          filename.includes('schema') ||\n          filename.includes('.sql') ||\n          filename.includes('database')) {\n        databaseMigrations = true;\n        requiresDeploymentCheck = true;\n      }\n      \n      // Infrastructure changes\n      if (filename.includes('dockerfile') ||\n          filename.includes('docker-compose') ||\n          filename.includes('.yml') ||\n          filename.includes('.yaml') ||\n          filename.includes('terraform') ||\n          filename.includes('cloudformation') ||\n          filename.includes('k8s') ||\n          filename.includes('kubernetes')) {\n        requiresDeploymentCheck = true;\n      }\n      \n      // Configuration changes\n      if (filename.includes('config') ||\n          filename.includes('.env') ||\n          filename.includes('package.json') ||\n          filename.includes('requirements.txt') ||\n          filename.includes('pom.xml') ||\n          filename.includes('build.gradle')) {\n        requiresDeploymentCheck = true;\n      }\n    });\n    \n    // Determine target environment based on branch or PR labels\n    const prText = `${pullRequest.title} ${pullRequest.body || ''}`.toLowerCase();\n    const branch = pullRequest.head.ref.toLowerCase();\n    \n    if (branch.includes('prod') || prText.includes('production')) {\n      targetEnvironment = 'production';\n    } else if (branch.includes('staging') || prText.includes('staging')) {\n      targetEnvironment = 'staging';\n    } else if (branch.includes('dev') || prText.includes('development')) {\n      targetEnvironment = 'development';\n    }\n    \n    return { \n      requiresDeploymentCheck, \n      apiChanges, \n      databaseMigrations, \n      targetEnvironment \n    };\n  }\n\n  /**\n   * Determine if code review is required\n   */\n  private requiresCodeReview(complexity: string, totalLines: number): boolean {\n    // Always require code review for medium/high complexity or significant changes\n    return complexity !== 'low' || totalLines > 50;\n  }\n\n  /**\n   * Calculate overall risk level\n   */\n  private calculateRiskLevel(factors: {\n    complexity: string;\n    securityConcerns: number;\n    linesChanged: number;\n    filesChanged: number;\n    hasApiChanges: boolean;\n    hasDatabaseChanges: boolean;\n  }): 'low' | 'medium' | 'high' | 'critical' {\n    let riskScore = 0;\n    \n    // Complexity factor\n    switch (factors.complexity) {\n      case 'high': riskScore += 3; break;\n      case 'medium': riskScore += 2; break;\n      case 'low': riskScore += 1; break;\n    }\n    \n    // Security concerns\n    if (factors.securityConcerns > 5) riskScore += 3;\n    else if (factors.securityConcerns > 2) riskScore += 2;\n    else if (factors.securityConcerns > 0) riskScore += 1;\n    \n    // Change magnitude\n    if (factors.linesChanged > 2000) riskScore += 3;\n    else if (factors.linesChanged > 1000) riskScore += 2;\n    else if (factors.linesChanged > 500) riskScore += 1;\n    \n    if (factors.filesChanged > 50) riskScore += 2;\n    else if (factors.filesChanged > 20) riskScore += 1;\n    \n    // Critical changes\n    if (factors.hasApiChanges) riskScore += 2;\n    if (factors.hasDatabaseChanges) riskScore += 3;\n    \n    // Determine risk level\n    if (riskScore >= 10) return 'critical';\n    if (riskScore >= 7) return 'high';\n    if (riskScore >= 4) return 'medium';\n    return 'low';\n  }\n\n  /**\n   * Estimate review time in minutes\n   */\n  private estimateReviewTime(factors: {\n    complexity: string;\n    filesCount: number;\n    linesChanged: number;\n    requiresSecurityReview: boolean;\n    requiresPerformanceReview: boolean;\n  }): number {\n    let baseTime = 10; // Base 10 minutes\n    \n    // File count factor (2 minutes per file)\n    baseTime += factors.filesCount * 2;\n    \n    // Lines changed factor (1 minute per 100 lines)\n    baseTime += Math.ceil(factors.linesChanged / 100);\n    \n    // Complexity multiplier\n    switch (factors.complexity) {\n      case 'high': baseTime *= 2; break;\n      case 'medium': baseTime *= 1.5; break;\n    }\n    \n    // Special review requirements\n    if (factors.requiresSecurityReview) baseTime += 30;\n    if (factors.requiresPerformanceReview) baseTime += 20;\n    \n    // Cap at reasonable maximum\n    return Math.min(baseTime, 480); // Max 8 hours\n  }\n}
