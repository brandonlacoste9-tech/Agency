"use strict";
n;
nimport;
{
    Octokit;
}
from;
'@octokit/rest';
nimport;
{
    Logger;
}
from;
'../../lib/logger';
nimport;
{
    PRReportData, SecurityIssue, CodeQualityIssue, PerformanceIssue;
}
from;
'./types';
n;
nexport;
class GitHubReporter {
    n;
    octokit;
    n;
    logger;
    n;
    n;
    constructor(octokit, logger) { n; this.octokit = octokit; n; this.logger = logger; n; }
    n;
    n; /**\n   * Report that PR processing has started\n   */
    n;
    async reportPRProcessingStarted(pr, repository, analysis) { n; try {
        n;
    }
    finally { } }
} // Create check run for tracking progress\n      await this.octokit.checks.create({\n        owner: repository.owner.login,\n        repo: repository.name,\n        name: 'AI PR Review',\n        head_sha: pr.head.sha,\n        status: 'in_progress',\n        started_at: new Date().toISOString(),\n        output: {\n          title: 'Automated PR Review in Progress',\n          summary: `Analyzing PR with ${analysis.modifiedFiles.length} files changed. Estimated time: ${analysis.estimatedReviewTime} minutes.`\n        }\n      });\n\n      // Post initial comment\n      const initialComment = `## ü§ñ Automated PR Review Started\n\n**Analysis Summary:**\n- **Files changed:** ${analysis.modifiedFiles.length}\n- **Lines added:** ${analysis.addedLines}\n- **Lines deleted:** ${analysis.deletedLines}\n- **Complexity:** ${analysis.complexity}\n- **Risk level:** ${analysis.riskLevel}\n- **Estimated review time:** ${analysis.estimatedReviewTime} minutes\n\n**Checks being performed:**\n${analysis.requiresSecurityReview ? 'üîí Security review' : ''}\n${analysis.requiresCodeReview ? 'üìù Code quality review' : ''}\n${analysis.requiresTesting ? 'üß™ Test coverage analysis' : ''}\n${analysis.requiresDocumentation ? 'üìö Documentation review' : ''}\n${analysis.requiresPerformanceReview ? '‚ö° Performance analysis' : ''}\n${analysis.requiresDeploymentCheck ? 'üöÄ Deployment readiness' : ''}\n\nI'll update you as each check completes. You can use commands like \`/status\` to get current progress.`;\n\n      await this.postComment(pr, repository, initialComment);\n\n      this.logger.info('PR processing started notification sent', {\n        pr: `${repository.full_name}#${pr.number}`\n      });\n\n    } catch (error) {\n      this.logger.error('Error reporting PR processing start', {\n        pr: `${repository.full_name}#${pr.number}`,\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  }\n\n  /**\n   * Post final comprehensive report\n   */\n  async postFinalReport(pr: any, repository: any, report: PRReportData): Promise<void> {\n    try {\n      const reportComment = this.generateFinalReportComment(report);\n      await this.postComment(pr, repository, reportComment);\n\n      // Update check run with final status\n      const conclusion = report.summary.status === 'success' ? 'success' : \n                        report.summary.status === 'warning' ? 'neutral' : 'failure';\n      \n      await this.updateCheckStatus(pr, repository, conclusion, \n        `Review completed: ${report.summary.status}`);\n\n      this.logger.info('Final report posted', {\n        pr: `${repository.full_name}#${pr.number}`,\n        status: report.summary.status\n      });\n\n    } catch (error) {\n      this.logger.error('Error posting final report', {\n        pr: `${repository.full_name}#${pr.number}`,\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  }\n\n  /**\n   * Post security alert\n   */\n  async postSecurityAlert(pr: any, repository: any, securityIssues: SecurityIssue[]): Promise<void> {\n    const alertComment = this.generateSecurityAlert(securityIssues);\n    await this.postComment(pr, repository, alertComment);\n    \n    // Add security label\n    await this.addLabels(pr, repository, ['security-review-required']);\n  }\n\n  /**\n   * Post code review suggestions\n   */\n  async postCodeReviewSuggestions(pr: any, repository: any, suggestions: CodeQualityIssue[]): Promise<void> {\n    const suggestionsComment = this.generateCodeReviewComment(suggestions);\n    await this.postComment(pr, repository, suggestionsComment);\n  }\n\n  /**\n   * Post test results\n   */\n  async postTestResults(pr: any, repository: any, testResults: any): Promise<void> {\n    const testComment = this.generateTestResultsComment(testResults);\n    await this.postComment(pr, repository, testComment);\n  }\n\n  /**\n   * Post documentation reminder\n   */\n  async postDocumentationReminder(pr: any, repository: any, missingDocs: string[]): Promise<void> {\n    const docComment = this.generateDocumentationComment(missingDocs);\n    await this.postComment(pr, repository, docComment);\n    \n    await this.addLabels(pr, repository, ['documentation-needed']);\n  }\n\n  /**\n   * Post performance alert\n   */\n  async postPerformanceAlert(pr: any, repository: any, performanceIssues: PerformanceIssue[]): Promise<void> {\n    const perfComment = this.generatePerformanceComment(performanceIssues);\n    await this.postComment(pr, repository, perfComment);\n    \n    await this.addLabels(pr, repository, ['performance-review']);\n  }\n\n  /**\n   * Post deployment status\n   */\n  async postDeploymentStatus(pr: any, repository: any, deploymentInfo: any): Promise<void> {\n    const deploymentComment = this.generateDeploymentComment(deploymentInfo);\n    await this.postComment(pr, repository, deploymentComment);\n  }\n\n  /**\n   * Post a comment to PR or issue\n   */\n  async postComment(pr: any, repository: any, body: string): Promise<void> {\n    await this.octokit.issues.createComment({\n      owner: repository.owner.login,\n      repo: repository.name,\n      issue_number: pr.number,\n      body\n    });\n  }\n\n  /**\n   * Update check status\n   */\n  async updateCheckStatus(pr: any, repository: any, conclusion: string, summary: string): Promise<void> {\n    try {\n      // Find existing check run\n      const { data: checkRuns } = await this.octokit.checks.listForRef({\n        owner: repository.owner.login,\n        repo: repository.name,\n        ref: pr.head.sha,\n        check_name: 'AI PR Review'\n      });\n\n      if (checkRuns.check_runs.length > 0) {\n        await this.octokit.checks.update({\n          owner: repository.owner.login,\n          repo: repository.name,\n          check_run_id: checkRuns.check_runs[0].id,\n          status: 'completed',\n          conclusion: conclusion as any,\n          completed_at: new Date().toISOString(),\n          output: {\n            title: 'Automated PR Review Completed',\n            summary\n          }\n        });\n      }\n    } catch (error) {\n      this.logger.error('Error updating check status', {\n        pr: `${repository.full_name}#${pr.number}`,\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  }\n\n  /**\n   * Add labels to PR\n   */\n  async addLabels(pr: any, repository: any, labels: string[]): Promise<void> {\n    try {\n      await this.octokit.issues.addLabels({\n        owner: repository.owner.login,\n        repo: repository.name,\n        issue_number: pr.number,\n        labels\n      });\n    } catch (error) {\n      this.logger.error('Error adding labels', {\n        pr: `${repository.full_name}#${pr.number}`,\n        labels,\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  }\n\n  /**\n   * Report error during processing\n   */\n  async reportError(pr: any, repository: any, error: Error): Promise<void> {\n    const errorComment = `## ‚ùå Automated Review Error\n\nAn error occurred during the automated review process:\n\n\`\`\`\n${error.message}\n\`\`\`\n\nPlease try running the review again with \`/full-review\` or contact the team if the issue persists.`;\n    \n    await this.postComment(pr, repository, errorComment);\n    \n    await this.updateCheckStatus(pr, repository, 'failure', \n      `Review failed: ${error.message}`);\n  }\n\n  // Comment generation methods\n  \n  private generateFinalReportComment(report: PRReportData): string {\n    const statusEmoji = {\n      success: '‚úÖ',\n      warning: '‚ö†Ô∏è',\n      failure: '‚ùå'\n    };\n\n    return `## ${statusEmoji[report.summary.status]} Automated PR Review Complete\n\n### Summary\n- **Status:** ${report.summary.status.toUpperCase()}\n- **Total tasks:** ${report.summary.totalTasks}\n- **Completed:** ${report.summary.completedTasks}\n- **Failed:** ${report.summary.failedTasks}\n- **Execution time:** ${Math.round(report.summary.executionTime / 1000)}s\n\n### Security Analysis\n- **Score:** ${report.security.score}/100\n- **Risk Level:** ${report.security.riskLevel}\n- **Issues found:** ${report.security.issues.length}\n\n### Code Quality\n- **Score:** ${report.codeQuality.score}/100\n- **Maintainability Index:** ${report.codeQuality.maintainabilityIndex}\n- **Complexity:** ${report.codeQuality.complexity}\n- **Issues found:** ${report.codeQuality.issues.length}\n\n### Testing\n- **Coverage:** ${report.testing.coverage}%\n- **Tests passed:** ${report.testing.testsPassed}\n- **Tests failed:** ${report.testing.testsFailed}\n- **New tests added:** ${report.testing.newTests}\n\n### Performance\n- **Score:** ${report.performance.score}/100\n- **Issues found:** ${report.performance.issues.length}\n- **Regressions:** ${report.performance.regressions.length}\n\n### Documentation\n- **Coverage:** ${report.documentation.coverage}%\n- **Missing docs:** ${report.documentation.missingDocs.length}\n- **Outdated docs:** ${report.documentation.outdatedDocs.length}\n\n### Deployment\n- **Readiness:** ${report.deployment.readiness}\n- **Checks:** ${report.deployment.checks.filter(c => c.status === 'passed').length}/${report.deployment.checks.length} passed\n- **Migrations:** ${report.deployment.migrations.length}\n\n${report.recommendations.length > 0 ? `### Recommendations\n${report.recommendations.map(rec => `- ${rec}`).join('\\n')}\n` : ''}\n\n### Metrics\n- **Total execution time:** ${Math.round(report.metrics.totalExecutionTime / 1000)}s\n- **Average task time:** ${Math.round(report.metrics.averageTaskTime / 1000)}s\n- **Success rate:** ${Math.round(report.metrics.successRate * 100)}%\n\n---\n*This report was generated automatically by the AI PR Review system.*`;\n  }\n\n  private generateSecurityAlert(issues: SecurityIssue[]): string {\n    const criticalIssues = issues.filter(i => i.severity === 'critical');\n    const highIssues = issues.filter(i => i.severity === 'high');\n    \n    let alert = `## üîí Security Review Alert\n\n**${issues.length} security issue(s) found**\n\n`;\n    \n    if (criticalIssues.length > 0) {\n      alert += `### üö® Critical Issues (${criticalIssues.length})\n`;\n      criticalIssues.forEach(issue => {\n        alert += `- **${issue.type}** in \`${issue.file}\`${issue.line ? `:${issue.line}` : ''}\n`;\n        alert += `  ${issue.description}\n`;\n        alert += `  **Recommendation:** ${issue.recommendation}\n\n`;\n      });\n    }\n    \n    if (highIssues.length > 0) {\n      alert += `### ‚ö†Ô∏è High Priority Issues (${highIssues.length})\n`;\n      highIssues.forEach(issue => {\n        alert += `- **${issue.type}** in \`${issue.file}\`${issue.line ? `:${issue.line}` : ''}\n`;\n        alert += `  ${issue.description}\n`;\n        alert += `  **Recommendation:** ${issue.recommendation}\n\n`;\n      });\n    }\n    \n    alert += `**Please address these security concerns before merging.**`;\n    \n    return alert;\n  }\n\n  private generateCodeReviewComment(suggestions: CodeQualityIssue[]): string {\n    const majorIssues = suggestions.filter(s => s.severity === 'major' || s.severity === 'critical');\n    const minorIssues = suggestions.filter(s => s.severity === 'minor' || s.severity === 'info');\n    \n    let comment = `## üìù Code Quality Review\n\n**${suggestions.length} suggestion(s) found**\n\n`;\n    \n    if (majorIssues.length > 0) {\n      comment += `### Major Issues (${majorIssues.length})\n`;\n      majorIssues.forEach(issue => {\n        comment += `- **${issue.type}** in \`${issue.file}\`${issue.line ? `:${issue.line}` : ''}\n`;\n        comment += `  ${issue.description}\n`;\n        comment += `  **Suggestion:** ${issue.suggestion}\n`;\n        comment += `  **Effort:** ${issue.effort}\n\n`;\n      });\n    }\n    \n    if (minorIssues.length > 0) {\n      comment += `<details><summary>Minor Issues (${minorIssues.length})</summary>\n\n`;\n      minorIssues.forEach(issue => {\n        comment += `- **${issue.type}** in \`${issue.file}\`${issue.line ? `:${issue.line}` : ''}\n`;\n        comment += `  ${issue.description}\n`;\n        comment += `  **Suggestion:** ${issue.suggestion}\n\n`;\n      });\n      comment += `</details>\n\n`;\n    }\n    \n    return comment;\n  }\n\n  private generateTestResultsComment(results: any): string {\n    return `## üß™ Test Results\n\n- **Coverage:** ${results.coverage}%\n- **Tests passed:** ${results.testsPassed}\n- **Tests failed:** ${results.testsFailed}\n- **New tests:** ${results.newTests}\n\n${results.missingTests?.length > 0 ? `**Missing test coverage for:**\n${results.missingTests.map((test: string) => `- ${test}`).join('\\n')}\n\n` : ''}${results.testsFailed > 0 ? '**Please fix failing tests before merging.**' : '**All tests passing! üéâ**'}`;\n  }\n\n  private generateDocumentationComment(missingDocs: string[]): string {\n    return `## üìö Documentation Review\n\n**Documentation updates needed:**\n\n${missingDocs.map(doc => `- ${doc}`).join('\\n')}\n\nPlease update the relevant documentation to reflect your changes.`;\n  }\n\n  private generatePerformanceComment(issues: PerformanceIssue[]): string {\n    const criticalIssues = issues.filter(i => i.severity === 'critical' || i.severity === 'high');\n    \n    let comment = `## ‚ö° Performance Review\n\n**${issues.length} performance issue(s) found**\n\n`;\n    \n    if (criticalIssues.length > 0) {\n      comment += `### Critical/High Priority Issues\n`;\n      criticalIssues.forEach(issue => {\n        comment += `- **${issue.type}** in \`${issue.file}\`${issue.line ? `:${issue.line}` : ''}\n`;\n        comment += `  ${issue.description}\n`;\n        comment += `  **Impact:** ${issue.impact}\n`;\n        comment += `  **Suggestion:** ${issue.suggestion}\n\n`;\n      });\n    }\n    \n    return comment;\n  }\n\n  private generateDeploymentComment(deploymentInfo: any): string {\n    const passedChecks = deploymentInfo.checks?.filter((c: any) => c.status === 'passed') || [];\n    const failedChecks = deploymentInfo.checks?.filter((c: any) => c.status === 'failed') || [];\n    \n    let comment = `## üöÄ Deployment Readiness\n\n**Status:** ${deploymentInfo.readiness}\n\n`;\n    \n    if (passedChecks.length > 0) {\n      comment += `### ‚úÖ Passed Checks (${passedChecks.length})\n`;\n      passedChecks.forEach((check: any) => {\n        comment += `- ${check.name}: ${check.description}\\n`;\n      });\n      comment += '\\n';\n    }\n    \n    if (failedChecks.length > 0) {\n      comment += `### ‚ùå Failed Checks (${failedChecks.length})\n`;\n      failedChecks.forEach((check: any) => {\n        comment += `- ${check.name}: ${check.description}\\n`;\n      });\n      comment += '\\n';\n    }\n    \n    if (deploymentInfo.migrations?.length > 0) {\n      comment += `### Database Migrations (${deploymentInfo.migrations.length})\n`;\n      deploymentInfo.migrations.forEach((migration: any) => {\n        comment += `- ${migration.file} (${migration.type}) - Risk: ${migration.riskLevel}\\n`;\n      });\n    }\n    \n    return comment;\n  }\n}"
//# sourceMappingURL=github-reporter.js.map