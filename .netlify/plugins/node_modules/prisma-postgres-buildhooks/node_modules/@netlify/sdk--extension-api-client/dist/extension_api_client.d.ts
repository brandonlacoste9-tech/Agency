import { type Wretch } from "wretch";
import { NetlifyClient } from "./netlify_api_client.js";
export declare class AlreadyEnabledError extends Error {
    constructor();
}
export type ExtensionResponse<Config> = {
    id?: string | undefined;
    config: Config;
    has_build_hook_enabled: boolean;
};
export type ConfigurationResponse<Config> = {
    id: string;
    config: Config;
    createdAt: string;
    updatedAt: string;
    teamInstallationId: string;
    siteId?: string | undefined;
    dataLayerId?: string | undefined;
    configurationType: string;
    sourceUrl?: string | undefined;
    name?: string | undefined;
    prefix?: string | undefined;
};
type BuildTokenValidationResponse = {
    token: string;
    site_id: string;
    team_id?: string | undefined;
};
export type ExtensionClientOptions = {
    netlifyApiUrl?: string | undefined;
    jigsawUrl?: string | undefined;
};
export declare class NetlifyExtensionClient<SiteConfiguration, TeamConfiguration, ConnectorConfiguration> extends NetlifyClient {
    netlifyToken: string;
    extension: string;
    extensionApi: Wretch;
    teamConfigId?: string | undefined;
    siteConfigId?: string | undefined;
    constructor(netlifyToken: string, extension: string, { jigsawUrl, netlifyApiUrl }?: ExtensionClientOptions);
    /**
     * Installs this extension for a team.
     */
    installExtensionOnTeam: (teamId: string, hasDataIntegration?: boolean) => Promise<{
        token: string;
    }>;
    /**
     * Uninstalls this extension for a team.
     */
    uninstallExtensionOnTeam: (teamId: string) => Promise<import("wretch").WretchResponse>;
    /**
     * Upserts a configuration object of type 'team' for the extension installation
     */
    upsertTeamConfiguration: (teamId: string, config: TeamConfiguration) => Promise<import("wretch").WretchResponse>;
    /**
     * Creates a configuration object of type 'team' for the extension installation
     */
    createTeamConfiguration: (teamId: string, config: TeamConfiguration) => Promise<import("wretch").WretchResponse>;
    /**
     * Updates a configuration object of type 'team' for the extension installation
     */
    updateTeamConfiguration: (teamId: string, config: TeamConfiguration) => Promise<import("wretch").WretchResponse>;
    /**
     * Gets a configuration object of type 'team' for the extension installation.
     */
    getTeamConfiguration: (teamId: string) => Promise<ConfigurationResponse<TeamConfiguration> | null>;
    /**
     * Updates a configuration object of type 'team' for the extension installation
     */
    deleteTeamConfiguration: (teamId: string) => Promise<import("wretch").WretchResponse>;
    /**
     * Upserts a configuration object of type 'site' for the extension installation
     */
    upsertSiteConfiguration: (teamId: string, siteId: string, config: SiteConfiguration) => Promise<import("wretch").WretchResponse>;
    /**
     * Creates a configuration object of type 'site' for the extension installation
     */
    createSiteConfiguration: (teamId: string, siteId: string, config: SiteConfiguration) => Promise<import("wretch").WretchResponse>;
    /**
     * Updates a configuration object of type 'site' for the extension installation
     */
    updateSiteConfiguration: (teamId: string, siteId: string, config: SiteConfiguration) => Promise<import("wretch").WretchResponse>;
    /**
     * Gets a configuration object of type 'site' for the extension installation.
     */
    getSiteConfiguration: (teamId: string, siteId: string) => Promise<ConfigurationResponse<SiteConfiguration> | null>;
    /**
     * deletes a configuration object of type 'site' for the extension installation
     */
    deleteSiteConfiguration: (teamId: string, siteId: string) => Promise<import("wretch").WretchResponse>;
    /**
     * Creates a 'one of many' configuration object of type 'connect' for the extension installation
     */
    createConnectConfiguration: ({ teamId, dataLayerId, config, name, prefix, }: {
        teamId: string;
        dataLayerId: string;
        config: ConnectorConfiguration;
        name: string;
        prefix?: string;
    }) => Promise<import("wretch").WretchResponse>;
    /**
     * Gets a configuration object of type 'connect' for the extension installation with a specific configuration ID
     */
    getConnectConfiguration: ({ teamId, dataLayerId, configurationId, }: {
        teamId: string;
        dataLayerId: string;
        configurationId: string;
    }) => Promise<ConfigurationResponse<ConnectorConfiguration> | null>;
    /**
     * Updates a configuration object of type 'connect' for the extension installation for a specific configuration ID.
     */
    updateConnectConfiguration: ({ teamId, dataLayerId, configurationId, name, prefix, config, }: {
        teamId: string;
        dataLayerId: string;
        configurationId: string;
        name: string;
        prefix?: string;
        config: ConnectorConfiguration;
    }) => Promise<import("wretch").WretchResponse>;
    /**
     * deletes a configuration object of type 'connect' for the extension installation
     */
    deleteConnectConfiguration: ({ teamId, dataLayerId, configurationId, }: {
        teamId: string;
        dataLayerId: string;
        configurationId: string;
    }) => Promise<import("wretch").WretchResponse>;
    /**
     * Creates a 'one of many' configuration object of type 'create' for the extension installation
     */
    createVisualEditorConfiguration: ({ teamId, siteId, config, name, projectId, prefix, notifyVisualEditor, }: {
        teamId: string;
        siteId: string;
        config: ConnectorConfiguration;
        name: string;
        projectId: string;
        prefix: string;
        notifyVisualEditor?: boolean;
    }) => Promise<import("wretch").WretchResponse>;
    /**
     * Gets a configuration object of type 'create' for the extension installation with a specific configuration ID
     */
    getVisualEditorConfiguration: ({ teamId, siteId, configurationId, }: {
        teamId: string;
        siteId: string;
        configurationId: string;
    }) => Promise<ConfigurationResponse<ConnectorConfiguration> | null>;
    /**
     * Updates a configuration object of type 'create' for the extension installation for a specific configuration ID.
     */
    updateVisualEditorConfiguration: ({ teamId, siteId, configurationId, config, name, projectId, prefix, notifyVisualEditor, }: {
        teamId: string;
        siteId: string;
        configurationId: string;
        config: ConnectorConfiguration;
        name: string;
        projectId: string;
        prefix: string;
        notifyVisualEditor?: boolean;
    }) => Promise<import("wretch").WretchResponse>;
    /**
     * deletes a configuration object of type 'create' for the extension installation
     */
    deleteVisualEditorConfiguration: ({ teamId, siteId, configurationId, projectId, }: {
        teamId: string;
        siteId: string;
        configurationId: string;
        projectId: string;
    }) => Promise<import("wretch").WretchResponse>;
    /**
     * Generates a build token for a site, allowing a build hook to use the Build Context API.
     */
    generateBuildToken: (siteId: string, teamId: string) => Promise<{
        token: string;
    }>;
    /**
     * Validates a build token, returning the siteId and teamId if the token is valid and returning an error if the token is invalid.
     */
    exchangeBuildToken: (siteId: string, teamId: string) => Promise<BuildTokenValidationResponse>;
    /**
     * Sets the build token for a site. Build tokens can be created using the `generateBuildToken` method.
     */
    setBuildToken(accountId: string, siteId: string, token: string): Promise<void>;
    /**
     * Removes the build token for a site.
     */
    removeBuildToken(accountId: string, siteId: string): Promise<void>;
}
export {};
//# sourceMappingURL=extension_api_client.d.ts.map