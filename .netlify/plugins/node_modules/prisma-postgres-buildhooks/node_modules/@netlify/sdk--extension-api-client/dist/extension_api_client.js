import { default as w } from "wretch";
import { EXTENSION_API_URL_PROD } from "./constants.js";
import { NetlifyClient } from "./netlify_api_client.js";
import { envVarFromSlug } from "./utils.js";
export class AlreadyEnabledError extends Error {
    constructor() {
        super("Already enabled");
    }
}
export class NetlifyExtensionClient extends NetlifyClient {
    netlifyToken;
    extension;
    extensionApi;
    teamConfigId;
    siteConfigId;
    constructor(netlifyToken, extension, { jigsawUrl = "", netlifyApiUrl = "" } = {}) {
        super(netlifyToken, {
            baseUrl: netlifyApiUrl !== ""
                ? netlifyApiUrl
                : `${EXTENSION_API_URL_PROD}/api/v1`,
        });
        this.netlifyToken = netlifyToken;
        this.extension = extension;
        this.teamConfigId = undefined;
        this.siteConfigId = undefined;
        this.extensionApi = w()
            .url(jigsawUrl !== "" ? jigsawUrl : EXTENSION_API_URL_PROD)
            .headers({
            "netlify-token": netlifyToken,
            "Api-Version": "2",
        });
    }
    /**
     * Installs this extension for a team.
     */
    installExtensionOnTeam = async (teamId, hasDataIntegration = false) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/installation`)
            .post({ has_data_integration: hasDataIntegration })
            .json();
    };
    /**
     * Uninstalls this extension for a team.
     */
    uninstallExtensionOnTeam = async (teamId) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/installation`)
            .delete()
            .res();
    };
    /**
     * Upserts a configuration object of type 'team' for the extension installation
     */
    upsertTeamConfiguration = async (teamId, config) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/team`)
            .put({ config })
            .res();
    };
    /**
     * Creates a configuration object of type 'team' for the extension installation
     */
    createTeamConfiguration = async (teamId, config) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/team`)
            .put({ config })
            .res();
    };
    /**
     * Updates a configuration object of type 'team' for the extension installation
     */
    updateTeamConfiguration = async (teamId, config) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/team`)
            .put({ config })
            .res();
    };
    /**
     * Gets a configuration object of type 'team' for the extension installation.
     */
    getTeamConfiguration = async (teamId) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/team`)
            .get()
            .json()
            .catch((error) => {
            if (typeof error === "object" && error !== null && "status" in error) {
                const status = error.status;
                if (status === 404) {
                    return null;
                }
            }
            throw error;
        });
    };
    /**
     * Updates a configuration object of type 'team' for the extension installation
     */
    deleteTeamConfiguration = async (teamId) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/team`)
            .delete()
            .res();
    };
    /**
     * Upserts a configuration object of type 'site' for the extension installation
     */
    upsertSiteConfiguration = async (teamId, siteId, config) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/site/${siteId}`)
            .put({ config })
            .res();
    };
    /**
     * Creates a configuration object of type 'site' for the extension installation
     */
    createSiteConfiguration = async (teamId, siteId, config) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/site/${siteId}`)
            .put({ config })
            .res();
    };
    /**
     * Updates a configuration object of type 'site' for the extension installation
     */
    updateSiteConfiguration = async (teamId, siteId, config) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/site/${siteId}`)
            .put({ config })
            .res();
    };
    /**
     * Gets a configuration object of type 'site' for the extension installation.
     */
    getSiteConfiguration = async (teamId, siteId) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/site/${siteId}`)
            .get()
            .json()
            .catch((error) => {
            if (typeof error === "object" && error !== null && "status" in error) {
                const status = error.status;
                if (status === 404) {
                    return null;
                }
            }
            throw error;
        });
    };
    /**
     * deletes a configuration object of type 'site' for the extension installation
     */
    deleteSiteConfiguration = async (teamId, siteId) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/site/${siteId}`)
            .delete()
            .res();
    };
    /**
     * Creates a 'one of many' configuration object of type 'connect' for the extension installation
     */
    createConnectConfiguration = async ({ teamId, dataLayerId, config, name, prefix, }) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/connect/${dataLayerId}`)
            .post({ name, prefix, config })
            .res();
    };
    /**
     * Gets a configuration object of type 'connect' for the extension installation with a specific configuration ID
     */
    getConnectConfiguration = async ({ teamId, dataLayerId, configurationId, }) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/connect/${dataLayerId}/${configurationId}`)
            .get()
            .json()
            .catch((error) => {
            if (typeof error === "object" && error !== null && "status" in error) {
                const status = error.status;
                if (status === 404) {
                    return null;
                }
            }
            throw error;
        });
    };
    /**
     * Updates a configuration object of type 'connect' for the extension installation for a specific configuration ID.
     */
    updateConnectConfiguration = async ({ teamId, dataLayerId, configurationId, name, prefix, config, }) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/connect/${dataLayerId}/${configurationId}`)
            .patch({ name, prefix, config })
            .res();
    };
    /**
     * deletes a configuration object of type 'connect' for the extension installation
     */
    deleteConnectConfiguration = async ({ teamId, dataLayerId, configurationId, }) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/connect/${dataLayerId}/${configurationId}`)
            .delete()
            .res();
    };
    /**
     * Creates a 'one of many' configuration object of type 'create' for the extension installation
     */
    createVisualEditorConfiguration = async ({ teamId, siteId, config, name, projectId, prefix, notifyVisualEditor = true, }) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/create/${siteId}?project_id=${projectId}&notify_visual_editor=${notifyVisualEditor.toString()}`)
            .post({ name, config, prefix })
            .res();
    };
    /**
     * Gets a configuration object of type 'create' for the extension installation with a specific configuration ID
     */
    getVisualEditorConfiguration = async ({ teamId, siteId, configurationId, }) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/create/${siteId}/${configurationId}`)
            .get()
            .json()
            .catch((error) => {
            if (typeof error === "object" && error !== null && "status" in error) {
                const status = error.status;
                if (status === 404) {
                    return null;
                }
            }
            throw error;
        });
    };
    /**
     * Updates a configuration object of type 'create' for the extension installation for a specific configuration ID.
     */
    updateVisualEditorConfiguration = async ({ teamId, siteId, configurationId, config, name, projectId, prefix, notifyVisualEditor = true, }) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/create/${siteId}/${configurationId}?project_id=${projectId}&notify_visual_editor=${notifyVisualEditor.toString()}`)
            .patch({ name, config, prefix })
            .res();
    };
    /**
     * deletes a configuration object of type 'create' for the extension installation
     */
    deleteVisualEditorConfiguration = async ({ teamId, siteId, configurationId, projectId, }) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/configuration/create/${siteId}/${configurationId}?project_id=${projectId}`)
            .delete()
            .res();
    };
    /**
     * Generates a build token for a site, allowing a build hook to use the Build Context API.
     */
    generateBuildToken = async (siteId, teamId) => {
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/${siteId}/generate-build-token`)
            .post({})
            .json();
    };
    /**
     * Validates a build token, returning the siteId and teamId if the token is valid and returning an error if the token is invalid.
     */
    exchangeBuildToken = async (siteId, teamId) => {
        const extensionSecret = process.env["INTEGRATION_SECRET"];
        return this.extensionApi
            .url(`/team/${teamId}/integrations/${this.extension}/${siteId}/exchange-build-token`)
            .post({ token: this.netlifyToken, secret: extensionSecret })
            .json();
    };
    /**
     * Sets the build token for a site. Build tokens can be created using the `generateBuildToken` method.
     */
    async setBuildToken(accountId, siteId, token) {
        const safeSlug = envVarFromSlug(this.extension);
        await this.createOrUpdateVariable({
            accountId,
            siteId,
            key: `${safeSlug}_BUILD_TOKEN`,
            value: token,
        });
    }
    /**
     * Removes the build token for a site.
     */
    async removeBuildToken(accountId, siteId) {
        const safeSlug = envVarFromSlug(this.extension);
        await this.deleteEnvironmentVariable({
            accountId,
            siteId,
            key: `${safeSlug}_BUILD_TOKEN`,
        });
    }
}
//# sourceMappingURL=extension_api_client.js.map