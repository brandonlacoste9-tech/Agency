{"version":3,"file":"Dropdown.js","sources":["../../../src/components/Dropdown/Dropdown.tsx"],"sourcesContent":["import { Dropdown as BaseDropdown } from \"@netlify/ui\";\nimport React, { forwardRef, useMemo } from \"react\";\n\nexport const getInitialSelectedOption = <T,>(\n  options: DropdownOption<T>[],\n  initial?: DropdownOption<T> | number | undefined,\n): DropdownOption<T> | undefined => {\n  if (typeof initial === \"number\") {\n    return options[initial];\n  }\n  if (typeof initial === \"object\") {\n    return initial;\n  }\n  return options[0];\n};\n\nexport type DropdownOption<T = unknown> = {\n  /**\n   * A human-readable element rendered to represent the option.\n   */\n  label: React.ReactNode;\n\n  /**\n   * The programmatic value used when the option is selected.\n   */\n  value?: T | undefined;\n};\n\nexport type DropdownProps<T> = {\n  /**\n   * A class property to attach to the element.\n   *\n   * @see {@link !Element.className}\n   */\n  className?: string | undefined;\n\n  /**\n   * If `true`, the component is disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean | undefined;\n\n  /**\n   * An option or an index of an option from `options` to select on first render.\n   */\n  initialSelectedOption?: DropdownOption<T> | number | undefined;\n\n  /**\n   * A callback invoked when an option is selected.\n   */\n  onChange?: ((option: DropdownOption<T> | null) => void) | undefined;\n\n  /**\n   * A list of options to render in the dropdown.\n   */\n  options?: DropdownOption<T>[] | undefined;\n};\n\n/**\n * Dropdowns let users select from a list of options.\n *\n * <!-- TODO(ndhoule): Add a screenshot here -->\n *\n * @param props\n * @internal\n * @example\n * ```ts\n * import { Dropdown } from \"@netlify/sdk/react/components\";\n *\n * <Dropdown\n *   options=[\n *     { label: \"Pomeranian\", value: \"pomeranian\" },\n *     { label: \"Golden Retriever\", value: \"golden-retriever\" },\n *     { label: \"Doge\", value: \"shiba-inu\" },\n *   ]\n * />\n * ```\n */\nexport const Dropdown = forwardRef(function Dropdown<T>(\n  {\n    initialSelectedOption,\n    onChange,\n    options: originalOptions = [],\n    ...otherProps\n  }: DropdownProps<T>,\n  ref: React.ForwardedRef<HTMLFormElement>,\n) {\n  const options = useMemo<DropdownOption<T>[]>(\n    () => [{ label: <>&nbsp;</>, value: undefined }, ...originalOptions],\n    [originalOptions],\n  );\n  const initialSelectedItem = getInitialSelectedOption(\n    options,\n    initialSelectedOption,\n  );\n\n  return (\n    <BaseDropdown\n      // @ts-expect-error XXX(ndhoule): The Dropdown component technically accepts a ref, but it's\n      // not part of its public props interface.\n      ref={ref}\n      // We don't want to allow any unknown prop on Options, but if we don't, then the type conflicts\n      // with the base dropdown's Item type. Asserting like this lets us avoid a type error without\n      // allowing unknown properties on Options.\n      initialSelectedItem={initialSelectedItem}\n      items={options}\n      onSelect={onChange}\n      {...otherProps}\n    />\n  );\n}) as <T>(\n  props: DropdownProps<T> & {\n    ref?: React.ForwardedRef<HTMLElement> | undefined;\n  },\n) => JSX.Element;\n"],"names":["Dropdown","BaseDropdown"],"mappings":";;;AAGa,MAAA,2BAA2B,CACtC,SACA,YACkC;AAC9B,MAAA,OAAO,YAAY,UAAU;AAC/B,WAAO,QAAQ,OAAO;AAAA,EACxB;AACI,MAAA,OAAO,YAAY,UAAU;AACxB,WAAA;AAAA,EACT;AACA,SAAO,QAAQ,CAAC;AAClB;AAiEa,MAAA,WAAW,WAAW,SAASA,UAC1C;AAAA,EACE;AAAA,EACA;AAAA,EACA,SAAS,kBAAkB,CAAC;AAAA,EAC5B,GAAG;AACL,GACA,KACA;AACA,QAAM,UAAU;AAAA,IACd,MAAM,CAAC,EAAE,OAAO,oBAAA,UAAA,EAAE,UAAM,IAAA,CAAA,GAAK,OAAO,OAAa,GAAA,GAAG,eAAe;AAAA,IACnE,CAAC,eAAe;AAAA,EAAA;AAElB,QAAM,sBAAsB;AAAA,IAC1B;AAAA,IACA;AAAA,EAAA;AAIA,SAAA;AAAA,IAACC;AAAAA,IAAA;AAAA,MAGC;AAAA,MAIA;AAAA,MACA,OAAO;AAAA,MACP,UAAU;AAAA,MACT,GAAG;AAAA,IAAA;AAAA,EAAA;AAGV,CAAC;"}